

  Here's a complete example of how you could implement caching:

  <?php
  // app/Services/WorkStudio/CachedQueryService.php

  namespace App\Services\WorkStudio;

  use Illuminate\Support\Collection;
  use Illuminate\Support\Facades\Cache;

  class CachedQueryService
  {
      public function __construct(
          private GetQueryService $queryService,
      ) {}

      /**
       * Get system-wide metrics with caching.
       *
       * @param int $ttlMinutes Cache duration in minutes (default: 15)
       * @param bool $fresh Force fresh data from API
       */
      public function getSystemWideMetrics(int $ttlMinutes = 15, bool $fresh = 
  false): Collection
      {
          $cacheKey = $this->buildCacheKey('system_wide_metrics');

          if ($fresh) {
              Cache::forget($cacheKey);
          }

          return Cache::remember($cacheKey, now()->addMinutes($ttlMinutes),
  function () {
              return $this->queryService->getSystemWideMetrics();
          });
      }

      /**
       * Get regional data with caching.
       */
      public function getRegionalMetrics(int $ttlMinutes = 15, bool $fresh = 
  false): Collection
      {
          $cacheKey = $this->buildCacheKey('regional_metrics');

          if ($fresh) {
              Cache::forget($cacheKey);
          }

          return Cache::remember($cacheKey, now()->addMinutes($ttlMinutes),
  function () {
              // You'd add a method in GetQueryService for this
              return $this->queryService->executeAndHandle(
                  \App\Services\WorkStudio\Queries\VegPlanners\VegAssessmentQuer
  ies::groupedByRegionDataQuery()
              );
          });
      }

      /**
       * Invalidate all cached metrics.
       */
      public function invalidateAll(): void
      {
          Cache::forget($this->buildCacheKey('system_wide_metrics'));
          Cache::forget($this->buildCacheKey('regional_metrics'));
      }

      /**
       * Build a cache key with user/tenant context if needed.
       */
      private function buildCacheKey(string $key): string
      {
          // Include scope year to avoid stale data across years
          $scopeYear = config('ws_assessment_query.scope_year', date('Y'));

          return "ws_tracker:{$scopeYear}:{$key}";
      }
  }

  And here's how you would use it in a Livewire component:

  <?php
  // app/Livewire/Assessments/Dashboard/SystemMetrics.php

  namespace App\Livewire\Assessments\Dashboard;

  use App\Services\WorkStudio\CachedQueryService;
  use Illuminate\Support\Collection;
  use Livewire\Attributes\Computed;
  use Livewire\Attributes\Layout;
  use Livewire\Component;

  #[Layout('components.layout.app-shell', ['title' => 'System Metrics'])]
  class SystemMetrics extends Component
  {
      public bool $isLoading = false;

      #[Computed]
      public function metrics(): Collection
      {
          return app(CachedQueryService::class)->getSystemWideMetrics();
      }

      /**
       * Force refresh data from API (bypasses cache).
       */
      public function refreshData(): void
      {
          $this->isLoading = true;

          try {
              app(CachedQueryService::class)->getSystemWideMetrics(fresh: true);
              unset($this->metrics); // Clear computed cache

              $this->dispatch('notify', message: 'Data refreshed!', type:
  'success');
          } catch (\Exception $e) {
              $this->dispatch('notify', message: 'Refresh failed: ' .
  $e->getMessage(), type: 'error');
          } finally {
              $this->isLoading = false;
          }
      }

      public function render()
      {
          return view('livewire.assessments.dashboard.system-metrics');
      }
  }

  And the Blade view:

  {{-- resources/views/livewire/assessments/dashboard/system-metrics.blade.php
  --}}

  <div>
      <div class="flex justify-between items-center mb-6">
          <h2 class="text-lg font-semibold text-base-content">System-Wide
  Metrics</h2>

          <button
              wire:click="refreshData"
              wire:loading.attr="disabled"
              class="btn btn-sm btn-outline"
          >
              <span wire:loading.remove wire:target="refreshData">
                  <x-flux:icon name="refresh" class="w-4 h-4 mr-1" />
                  Refresh
              </span>
              <span wire:loading wire:target="refreshData">
                  <span class="loading loading-spinner loading-xs"></span>
                  Loading...
              </span>
          </button>
      </div>

      @if($this->metrics->isNotEmpty())
          @php $data = $this->metrics->first(); @endphp

          <div class="stats stats-vertical lg:stats-horizontal shadow w-full
  bg-base-100">
              <div class="stat">
                  <div class="stat-title">Total Circuits</div>
                  <div class="stat-value text-primary">{{
  number_format($data['Total_Circuits'] ?? 0) }}</div>
              </div>

              <div class="stat">
                  <div class="stat-title">Active</div>
                  <div class="stat-value text-success">{{
  number_format($data['Active_Count'] ?? 0) }}</div>
              </div>

              <div class="stat">
                  <div class="stat-title">In QC</div>
                  <div class="stat-value text-warning">{{
  number_format($data['QC_Count'] ?? 0) }}</div>
              </div>

              <div class="stat">
                  <div class="stat-title">Rework</div>
                  <div class="stat-value text-error">{{
  number_format($data['Rework_Count'] ?? 0) }}</div>
              </div>

              <div class="stat">
                  <div class="stat-title">Closed</div>
                  <div class="stat-value">{{ number_format($data['Closed_Count']
   ?? 0) }}</div>
              </div>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
              <div class="card bg-base-200">
                  <div class="card-body">
                      <h3 class="card-title text-sm">Total Miles</h3>
                      <p class="text-2xl font-bold">{{
  number_format($data['Total_Miles'] ?? 0, 2) }}</p>
                  </div>
              </div>

              <div class="card bg-base-200">
                  <div class="card-body">
                      <h3 class="card-title text-sm">Completed Miles</h3>
                      <p class="text-2xl font-bold text-success">{{
  number_format($data['Completed_Miles'] ?? 0, 2) }}</p>
                  </div>
              </div>

              <div class="card bg-base-200">
                  <div class="card-body">
                      <h3 class="card-title text-sm">Active Planners</h3>
                      <p class="text-2xl font-bold text-info">{{
  number_format($data['Active_Planners'] ?? 0) }}</p>
                  </div>
              </div>
          </div>
      @else
          <div class="alert">
              <span>No metrics data available.</span>
          </div>
      @endif
  </div>

  ★ Insight ─────────────────────────────────────
  Key Caching Decisions:

  1. TTL (Time-To-Live): 15 minutes is a reasonable default for dashboard data.
  You could increase this for data that changes less frequently.
  2. Cache Key Design: Including scope_year prevents showing 2025 data when the
  config changes to 2026.
  3. Manual Refresh Button: Lets users force a refresh when they know data has
  changed, without waiting for cache expiry.
  4. Computed Property + Caching: The Livewire #[Computed] caches within a
  single request; Laravel's Cache::remember() caches across requests. They work
  together nicely!
  ─────────────────────────────────────────────────

  Would you like me to:
  1. Create actual files with this implementation in your codebase?
  2. Show cache invalidation during sync operations (when new data arrives)?
  3. Add tagged caching so you can invalidate groups of related caches at once?

✻ Worked for 1m 16s